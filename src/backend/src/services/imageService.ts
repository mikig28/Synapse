import axios from 'axios';
import Replicate from 'replicate';
import ImageCache from '../models/ImageCache';

const replicate = new Replicate({ 
  auth: process.env.REPLICATE_API_TOKEN 
});

interface ImageResult {
  url: string;
  attribution?: string;
  source: 'unsplash' | 'replicate';
}

interface UnsplashResponse {
  urls?: {
    regular?: string;
  };
  user?: {
    name?: string;
  };
}

/**
 * Try to fetch an image from Unsplash API
 */
async function tryUnsplash(prompt: string): Promise<ImageResult | null> {
  if (!process.env.UNSPLASH_ACCESS_KEY) {
    console.log('Unsplash API key not configured, skipping...');
    return null;
  }

  try {
    const { data } = await axios.get<UnsplashResponse>(
      'https://api.unsplash.com/photos/random',
      { 
        params: { 
          query: prompt, 
          orientation: 'landscape',
          content_filter: 'high' // Filter out potentially inappropriate content
        },
        headers: { 
          Authorization: `Client-ID ${process.env.UNSPLASH_ACCESS_KEY}`
        },
        timeout: 5000 // 5 second timeout
      }
    );

    if (data?.urls?.regular) {
      const attribution = `Photo by ${data.user?.name || 'Unknown'} on Unsplash`;
      return {
        url: data.urls.regular,
        attribution,
        source: 'unsplash'
      };
    }
    return null;
  } catch (error: any) {
    console.log('Unsplash fetch failed:', error?.message || 'Unknown error');
    return null;
  }
}

/**
 * Generate image using FLUX-dev on Replicate
 */
async function generateFlux(prompt: string): Promise<ImageResult> {
  if (!process.env.REPLICATE_API_TOKEN) {
    throw new Error('Replicate API token not configured');
  }

  try {
    // Enhance prompt for news-appropriate imagery
    const enhancedPrompt = enhancePromptForNews(prompt);
    
    const [url] = await replicate.run('black-forest-labs/flux-dev', {
      input: {
        prompt: enhancedPrompt,
        aspect_ratio: '16:9',
        guidance: 3.5, // Slightly higher for better adherence to prompt
        num_inference_steps: 35, // More steps for better quality
        go_fast: true,
        output_format: 'webp',
        output_quality: 85,
        disable_safety_checker: false
      }
    }) as string[];

    return {
      url,
      source: 'replicate',
      attribution: 'Generated by FLUX AI'
    };
  } catch (error: any) {
    console.error('FLUX generation failed:', error);
    throw new Error(`Image generation failed: ${error?.message || 'Unknown error'}`);
  }
}

/**
 * Enhance prompt specifically for news content imagery
 */
function enhancePromptForNews(prompt: string): string {
  // Detect content type and add appropriate visual style
  const contentType = detectContentType(prompt);
  
  let styleModifiers = '';
  switch (contentType) {
    case 'technology':
      styleModifiers = 'modern tech illustration, clean digital design, professional technology imagery';
      break;
    case 'business':
      styleModifiers = 'professional business photography, corporate style, clean composition';
      break;
    case 'science':
      styleModifiers = 'scientific illustration, research imagery, educational style';
      break;
    case 'environment':
      styleModifiers = 'environmental photography, nature imagery, sustainability focus';
      break;
    case 'health':
      styleModifiers = 'medical illustration, healthcare imagery, professional medical style';
      break;
    case 'politics':
      styleModifiers = 'political imagery, governmental style, formal composition';
      break;
    default:
      styleModifiers = 'professional news photography, editorial style, clean composition';
  }
  
  // Add quality and safety modifiers
  const qualityModifiers = 'high quality, detailed, sharp focus, professional lighting';
  const safetyModifiers = 'appropriate for news media, suitable for all audiences';
  
  return `${prompt}, ${styleModifiers}, ${qualityModifiers}, ${safetyModifiers}`;
}

/**
 * Detect content type from prompt for better styling
 */
function detectContentType(prompt: string): string {
  const lowerPrompt = prompt.toLowerCase();
  
  const patterns = {
    technology: ['ai', 'artificial intelligence', 'tech', 'computer', 'software', 'digital', 'robot', 'innovation'],
    business: ['startup', 'funding', 'investment', 'company', 'corporate', 'finance', 'business', 'market'],
    science: ['research', 'study', 'discovery', 'experiment', 'scientist', 'laboratory', 'breakthrough'],
    environment: ['climate', 'environment', 'green', 'renewable', 'sustainability', 'nature', 'earth'],
    health: ['medical', 'health', 'doctor', 'hospital', 'medicine', 'treatment', 'vaccine', 'healthcare'],
    politics: ['government', 'election', 'political', 'president', 'congress', 'policy', 'vote']
  };
  
  for (const [type, keywords] of Object.entries(patterns)) {
    if (keywords.some(keyword => lowerPrompt.includes(keyword))) {
      return type;
    }
  }
  
  return 'general';
}

/**
 * Extract key topics from text for better image search
 */
function extractImagePrompt(text: string): string {
  // Clean up text and extract meaningful keywords
  const cleaned = text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  // Take first 50 characters to avoid overly long prompts
  return cleaned.substring(0, 50).trim();
}

/**
 * Generate a placeholder image URL based on the topic
 * This is a fallback when no API keys are available
 */
function generatePlaceholderImage(prompt: string): ImageResult {
  // Clean the prompt for URL use
  const cleanPrompt = prompt.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '+');
  
  // Use a free placeholder service that generates topic-relevant images
  const baseUrl = 'https://via.placeholder.com/800x450/4A90E2/FFFFFF';
  const textParam = encodeURIComponent(cleanPrompt.substring(0, 30));
  
  return {
    url: `${baseUrl}?text=${textParam}`,
    source: 'unsplash', // Mark as unsplash for consistency
    attribution: 'Placeholder image - Enable image APIs for AI-generated content'
  };
}

/**
 * Main function to get illustration for any topic
 * Uses cache-first approach, then Unsplash, then FLUX generation, then fallback
 */
export async function getIllustration(topic: string): Promise<ImageResult> {
  const prompt = extractImagePrompt(topic);
  
  if (!prompt) {
    throw new Error('Invalid topic provided for image generation');
  }

  // Check if any image service is available
  const hasUnsplash = !!process.env.UNSPLASH_ACCESS_KEY;
  const hasReplicate = !!process.env.REPLICATE_API_TOKEN;

  try {
    // 1. Check cache first
    const cached = await ImageCache.findOne({ prompt });
    if (cached) {
      console.log(`Using cached image for: ${prompt}`);
      return {
        url: cached.url,
        attribution: cached.attribution,
        source: cached.source
      };
    }

    // 2. If no API services available, use placeholder
    if (!hasUnsplash && !hasReplicate) {
      console.log(`No image APIs configured, using placeholder for: ${prompt}`);
      const placeholderResult = generatePlaceholderImage(prompt);
      
      // Save placeholder to cache
      try {
        await ImageCache.create({
          prompt,
          url: placeholderResult.url,
          source: placeholderResult.source,
          attribution: placeholderResult.attribution
        });
      } catch (cacheError: any) {
        console.warn('Failed to cache placeholder image:', cacheError?.message || 'Unknown error');
      }
      
      return placeholderResult;
    }

    // 3. Try Unsplash first (free and fast)
    console.log(`Searching Unsplash for: ${prompt}`);
    const unsplashResult = await tryUnsplash(prompt);
    
    let finalResult: ImageResult;
    
    if (unsplashResult) {
      finalResult = unsplashResult;
      console.log(`Found Unsplash image for: ${prompt}`);
    } else if (hasReplicate) {
      // 4. Fallback to FLUX generation
      console.log(`Generating FLUX image for: ${prompt}`);
      finalResult = await generateFlux(prompt);
      console.log(`Generated FLUX image for: ${prompt}`);
    } else {
      // 5. Final fallback to placeholder
      console.log(`No suitable image found, using placeholder for: ${prompt}`);
      finalResult = generatePlaceholderImage(prompt);
    }

    // 6. Save to cache
    try {
      await ImageCache.create({
        prompt,
        url: finalResult.url,
        source: finalResult.source,
        attribution: finalResult.attribution
      });
    } catch (cacheError: any) {
      // Don't fail if cache save fails
      console.warn('Failed to cache image:', cacheError?.message || 'Unknown error');
    }

    return finalResult;
  } catch (error) {
    console.error(`Failed to get illustration for "${topic}":`, error);
    
    // As a final fallback, return a placeholder image
    console.log(`Using emergency placeholder for: ${prompt}`);
    return generatePlaceholderImage(prompt);
  }
}

/**
 * Get multiple images for a list of topics
 */
export async function getMultipleIllustrations(topics: string[]): Promise<ImageResult[]> {
  const results = await Promise.allSettled(
    topics.map(topic => getIllustration(topic))
  );

  return results
    .filter((result): result is PromiseFulfilledResult<ImageResult> => 
      result.status === 'fulfilled'
    )
    .map(result => result.value);
}

/**
 * Clear old cache entries (useful for maintenance)
 */
export async function clearImageCache(olderThanDays: number = 7): Promise<number> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
  
  const result = await ImageCache.deleteMany({
    createdAt: { $lt: cutoffDate }
  });
  
  return result.deletedCount || 0;
} 