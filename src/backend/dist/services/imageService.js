"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIllustration = getIllustration;
exports.getMultipleIllustrations = getMultipleIllustrations;
exports.clearImageCache = clearImageCache;
const axios_1 = __importDefault(require("axios"));
const replicate_1 = __importDefault(require("replicate"));
const ImageCache_1 = __importDefault(require("../models/ImageCache"));
const replicate = new replicate_1.default({
    auth: process.env.REPLICATE_API_TOKEN
});
/**
 * Try to fetch an image from Unsplash API
 */
async function tryUnsplash(prompt) {
    if (!process.env.UNSPLASH_ACCESS_KEY) {
        console.log('Unsplash API key not configured, skipping...');
        return null;
    }
    try {
        const { data } = await axios_1.default.get('https://api.unsplash.com/photos/random', {
            params: {
                query: prompt,
                orientation: 'landscape',
                content_filter: 'high' // Filter out potentially inappropriate content
            },
            headers: {
                Authorization: `Client-ID ${process.env.UNSPLASH_ACCESS_KEY}`
            },
            timeout: 5000 // 5 second timeout
        });
        if (data?.urls?.regular) {
            const attribution = `Photo by ${data.user?.name || 'Unknown'} on Unsplash`;
            return {
                url: data.urls.regular,
                attribution,
                source: 'unsplash'
            };
        }
        return null;
    }
    catch (error) {
        console.log('Unsplash fetch failed:', error?.message || 'Unknown error');
        return null;
    }
}
/**
 * Generate image using FLUX-dev on Replicate
 */
async function generateFlux(prompt) {
    if (!process.env.REPLICATE_API_TOKEN) {
        throw new Error('Replicate API token not configured');
    }
    try {
        // Enhance prompt for news-appropriate imagery
        const enhancedPrompt = enhancePromptForNews(prompt);
        const [url] = await replicate.run('black-forest-labs/flux-dev', {
            input: {
                prompt: enhancedPrompt,
                aspect_ratio: '16:9',
                guidance: 3.5, // Slightly higher for better adherence to prompt
                num_inference_steps: 35, // More steps for better quality
                go_fast: true,
                output_format: 'webp',
                output_quality: 85,
                disable_safety_checker: false
            }
        });
        return {
            url,
            source: 'replicate',
            attribution: 'Generated by FLUX AI'
        };
    }
    catch (error) {
        console.error('FLUX generation failed:', error);
        throw new Error(`Image generation failed: ${error?.message || 'Unknown error'}`);
    }
}
/**
 * Enhance prompt specifically for news content imagery
 */
function enhancePromptForNews(prompt) {
    // Detect content type and add appropriate visual style
    const contentType = detectContentType(prompt);
    let styleModifiers = '';
    switch (contentType) {
        case 'technology':
            styleModifiers = 'modern tech illustration, clean digital design, professional technology imagery';
            break;
        case 'business':
            styleModifiers = 'professional business photography, corporate style, clean composition';
            break;
        case 'science':
            styleModifiers = 'scientific illustration, research imagery, educational style';
            break;
        case 'environment':
            styleModifiers = 'environmental photography, nature imagery, sustainability focus';
            break;
        case 'health':
            styleModifiers = 'medical illustration, healthcare imagery, professional medical style';
            break;
        case 'politics':
            styleModifiers = 'political imagery, governmental style, formal composition';
            break;
        default:
            styleModifiers = 'professional news photography, editorial style, clean composition';
    }
    // Add quality and safety modifiers
    const qualityModifiers = 'high quality, detailed, sharp focus, professional lighting';
    const safetyModifiers = 'appropriate for news media, suitable for all audiences';
    return `${prompt}, ${styleModifiers}, ${qualityModifiers}, ${safetyModifiers}`;
}
/**
 * Detect content type from prompt for better styling
 */
function detectContentType(prompt) {
    const lowerPrompt = prompt.toLowerCase();
    const patterns = {
        technology: ['ai', 'artificial intelligence', 'tech', 'computer', 'software', 'digital', 'robot', 'innovation'],
        business: ['startup', 'funding', 'investment', 'company', 'corporate', 'finance', 'business', 'market'],
        science: ['research', 'study', 'discovery', 'experiment', 'scientist', 'laboratory', 'breakthrough'],
        environment: ['climate', 'environment', 'green', 'renewable', 'sustainability', 'nature', 'earth'],
        health: ['medical', 'health', 'doctor', 'hospital', 'medicine', 'treatment', 'vaccine', 'healthcare'],
        politics: ['government', 'election', 'political', 'president', 'congress', 'policy', 'vote']
    };
    for (const [type, keywords] of Object.entries(patterns)) {
        if (keywords.some(keyword => lowerPrompt.includes(keyword))) {
            return type;
        }
    }
    return 'general';
}
/**
 * Extract key topics from text for better image search
 */
function extractImagePrompt(text) {
    // Clean up text and extract meaningful keywords
    const cleaned = text
        .toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    // Take first 50 characters to avoid overly long prompts
    return cleaned.substring(0, 50).trim();
}
/**
 * Generate a placeholder image URL based on the topic
 * This is a fallback when no API keys are available
 */
function generatePlaceholderImage(prompt) {
    // Clean the prompt for URL use
    const cleanPrompt = prompt.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '+');
    // Use a free placeholder service that generates topic-relevant images
    const baseUrl = 'https://via.placeholder.com/800x450/4A90E2/FFFFFF';
    const textParam = encodeURIComponent(cleanPrompt.substring(0, 30));
    return {
        url: `${baseUrl}?text=${textParam}`,
        source: 'unsplash', // Mark as unsplash for consistency
        attribution: 'Placeholder image - Enable image APIs for AI-generated content'
    };
}
/**
 * Main function to get illustration for any topic
 * Uses cache-first approach, then Unsplash, then FLUX generation, then fallback
 */
async function getIllustration(topic) {
    const prompt = extractImagePrompt(topic);
    if (!prompt) {
        throw new Error('Invalid topic provided for image generation');
    }
    // Check if any image service is available
    const hasUnsplash = !!process.env.UNSPLASH_ACCESS_KEY;
    const hasReplicate = !!process.env.REPLICATE_API_TOKEN;
    try {
        // 1. Check cache first
        const cached = await ImageCache_1.default.findOne({ prompt });
        if (cached) {
            console.log(`Using cached image for: ${prompt}`);
            return {
                url: cached.url,
                attribution: cached.attribution,
                source: cached.source
            };
        }
        // 2. If no API services available, use placeholder
        if (!hasUnsplash && !hasReplicate) {
            console.log(`No image APIs configured, using placeholder for: ${prompt}`);
            const placeholderResult = generatePlaceholderImage(prompt);
            // Save placeholder to cache
            try {
                await ImageCache_1.default.create({
                    prompt,
                    url: placeholderResult.url,
                    source: placeholderResult.source,
                    attribution: placeholderResult.attribution
                });
            }
            catch (cacheError) {
                console.warn('Failed to cache placeholder image:', cacheError?.message || 'Unknown error');
            }
            return placeholderResult;
        }
        // 3. Try Unsplash first (free and fast)
        console.log(`Searching Unsplash for: ${prompt}`);
        const unsplashResult = await tryUnsplash(prompt);
        let finalResult;
        if (unsplashResult) {
            finalResult = unsplashResult;
            console.log(`Found Unsplash image for: ${prompt}`);
        }
        else if (hasReplicate) {
            // 4. Fallback to FLUX generation
            console.log(`Generating FLUX image for: ${prompt}`);
            finalResult = await generateFlux(prompt);
            console.log(`Generated FLUX image for: ${prompt}`);
        }
        else {
            // 5. Final fallback to placeholder
            console.log(`No suitable image found, using placeholder for: ${prompt}`);
            finalResult = generatePlaceholderImage(prompt);
        }
        // 6. Save to cache
        try {
            await ImageCache_1.default.create({
                prompt,
                url: finalResult.url,
                source: finalResult.source,
                attribution: finalResult.attribution
            });
        }
        catch (cacheError) {
            // Don't fail if cache save fails
            console.warn('Failed to cache image:', cacheError?.message || 'Unknown error');
        }
        return finalResult;
    }
    catch (error) {
        console.error(`Failed to get illustration for "${topic}":`, error);
        // As a final fallback, return a placeholder image
        console.log(`Using emergency placeholder for: ${prompt}`);
        return generatePlaceholderImage(prompt);
    }
}
/**
 * Get multiple images for a list of topics
 */
async function getMultipleIllustrations(topics) {
    const results = await Promise.allSettled(topics.map(topic => getIllustration(topic)));
    return results
        .filter((result) => result.status === 'fulfilled')
        .map(result => result.value);
}
/**
 * Clear old cache entries (useful for maintenance)
 */
async function clearImageCache(olderThanDays = 7) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
    const result = await ImageCache_1.default.deleteMany({
        createdAt: { $lt: cutoffDate }
    });
    return result.deletedCount || 0;
}
