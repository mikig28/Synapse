--- a/src/backend/src/api/controllers/whatsappSummaryController.ts
+++ b/src/backend/src/api/controllers/whatsappSummaryController.ts
@@ -348,15 +348,18 @@
     }
     
     // Build comprehensive query for group messages
+    // Fix: Remove isIncoming filter and check both timestamp fields
     const baseQuery = {
       'metadata.isGroup': true,
-      isIncoming: true, // Only incoming messages for summary
-      createdAt: {  // Use createdAt instead of timestamp (timestamp field is corrupted)
-        $gte: utcStart,
-        $lte: utcEnd
-      }
+      // Don't filter by isIncoming to get all messages in the group
+      $or: [
+        { timestamp: { $gte: utcStart, $lte: utcEnd } },
+        { createdAt: { $gte: utcStart, $lte: utcEnd } }
+      ]
     };
 
+    console.log(`[WhatsApp Summary] Query time range: ${utcStart.toISOString()} to ${utcEnd.toISOString()}`);
+
     // Try multiple approaches to find group messages
     const queries = [
       // Primary: Direct group ID match
@@ -383,11 +386,18 @@
       
       messages = await WhatsAppMessage.find(query)
         .populate('contactId')
-        .sort({ createdAt: 1 })  // Sort by createdAt since that has correct timestamps
+        .sort({ timestamp: -1, createdAt: -1 })  // Try timestamp first, then createdAt
+        .limit(500)  // Limit to prevent memory issues
         .lean();
+      
+      // Reverse to get chronological order
+      messages = messages.reverse();
         
       console.log(`[WhatsApp Summary] ${queryUsed} returned ${messages.length} messages`);
       
+      // Log sample message structure for debugging
+      if (messages.length > 0) {
+        console.log(`[WhatsApp Summary] Sample message structure:`, JSON.stringify(messages[0], null, 2).substring(0, 500));
+      }
       if (messages.length > 0) {
         const firstMsg = messages[0];
         const lastMsg = messages[messages.length - 1];
@@ -404,18 +414,23 @@
       
       const fallbackQuery = {
         'metadata.isGroup': true,
-        isIncoming: true,
-        $or: [
+        // Remove isIncoming filter
+        $and: [
+          {
+            $or: [
+              { 'metadata.groupId': groupId },
+              { 'metadata.groupName': groupInfo.name },
+              { to: groupId },
+              { from: { $regex: groupId } }  // Also check from field
+            ]
+          },
+          {
+            $or: [
+              { timestamp: { $gte: fallbackStart, $lte: fallbackEnd } },
+              { createdAt: { $gte: fallbackStart, $lte: fallbackEnd } }
+            ]
+          }
         ],
-        createdAt: { $gte: fallbackStart, $lte: fallbackEnd }
       };
       
       console.log('[WhatsApp Summary] Fallback query:', JSON.stringify(fallbackQuery, null, 2));
@@ -451,9 +466,18 @@
     // Transform to MessageData format
     const messageData: MessageData[] = messages.map(msg => ({
       id: msg.messageId || msg._id.toString(),
       message: msg.message || '',
-      timestamp: msg.timestamp,
+      // Use timestamp if available, otherwise use createdAt
+      timestamp: msg.timestamp || msg.createdAt,
       type: msg.type || 'text',
-      senderName: (msg.contactId as any)?.name || `Contact ${msg.from}`,
+      // Better sender name handling
+      senderName: (msg.contactId as any)?.name || 
+                  (msg.contactId as any)?.pushName || 
+                  (msg.metadata as any)?.senderName ||
+                  msg.from?.split('@')[0] || 
+                  `Contact ${msg.from}`,
       senderPhone: msg.from
     }));
+    
+    console.log(`[WhatsApp Summary] Processed ${messageData.length} messages with ${new Set(messageData.map(m => m.senderPhone)).size} unique senders`);
     
     // Generate summary